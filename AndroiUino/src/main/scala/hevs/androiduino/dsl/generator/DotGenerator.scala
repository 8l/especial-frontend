package hevs.androiduino.dsl.generator

import java.io.File

import grizzled.slf4j.Logging
import hevs.androiduino.dsl.components.ComponentManager
import hevs.androiduino.dsl.components.ComponentManager.Wire
import hevs.androiduino.dsl.components.fundamentals.{Component, InputPort, OutputPort, Port}
import hevs.androiduino.dsl.utils.{OSUtils, Version}

import scala.language.existentials
import scalax.collection.Graph
import scalax.collection.edge.LDiEdge
import scalax.collection.io.dot._

object DotGenerator extends Logging {

  /* General dot diagrams settings */
  private val dotSettings =
    """
      |	// Diagram settings
      |	graph [rankdir=LR labelloc=b, fontname=Arial, fontsize=14];
      |	node [ fontname=serif, fontsize=11, shape=Mrecord];
      |	edge [ fontname=Courier, color=dimgrey fontsize=12 ];
      |
      |	// Exported nodes from the components graph
    """.stripMargin

  private val dotHeader =
    """// This file was auto-generated by DotGenerator version %s
      |// Visualisation of the '%s' program.""".stripMargin

  /**
   * Generate the dot file, save it and also export the pdf version.
   * @param graphName the title to display on the graph
   * @param fileName the name of the dot and pdf file
   */
  def generateDotFile(graphName: String, fileName: String) = {
    val path = s"output/dot/$fileName.dot"
    val dot = generateDot(graphName)
    val f: RichFile = new File(path) // Create the DOT file in the folder "output/dot/"
    f.write(dot)
    convertDotToPdf(fileName) // Export the DOT image
  }

  /**
   * Generate the dot file and return it as a String.
   * @param graphName the title to display on the graph
   * @return the dot file as a String
   */
  def generateDot(graphName: String): String = {
    val dot = new DotGenerator(graphName).generateDot()
    // Add static settings by hand after the first line
    val dotLines = dot.split("\\r?\\n\\t", 2)
    dotLines(0) += dotSettings
    // Add the file header
    val header = String.format(dotHeader, Version.getVersion, graphName)
    header + "\n" + dotLines.mkString
  }

  private def convertDotToPdf(fileName: String) = {
    // FIXME: use a pipeline for this

    // Convert the dot file to PDF with the same file name
    val path = s"output/dot/$fileName"

    // Check the if dot is installed and print the installed version
    val valid = OSUtils.runWithBooleanResult("dot -V")
    if (valid._1) {
      info(s"Running '${valid._2}'.")
      OSUtils.runWithResult(s"dot $path.dot -Tpdf -o $path.pdf")
    }
    else
      error("Unable to run dot. Must be installed and in the PATH !")
  }
}

/**
 * Display the graph of the `ComponentManager` on a DOT diagram.
 * Components are the nodes, connected together with ports. The label on the edge describe the type
 * of the connection - from an OutputPort to an InputPort of two components. Unconnected ports are display as "NC".
 * Unconnected components (nodes) are in orange.
 * @param graphName the title to display on the graph
 */
class DotGenerator(val graphName: String) {

  // Basic diagram settings and title
  private val name = "\"Visualisation of the '" + graphName + "' program.\""
  private val root = DotRootGraph(directed = true, id = Some("G"), kvList = Seq(DotAttr("label", name)))

  /**
   * Generate the DOT diagram of the `ComponentManager` graph.
   * @return the dot file as a String
   */
  private def generateDot(): String = {
    // Generate the dot diagram and return it as String
    val g = ComponentManager.cpGraph
    g.toDot(root, edgeTransformer,
      hEdgeTransformer = Option(edgeTransformer),
      iNodeTransformer = Option(nodeTrans),
      cNodeTransformer = Option(nodeTrans))
  }

  /**
   * Transform all connected nodes.
   * @param innerNode graph nodes
   * @return the same transformation for all connected nodes of the graph
   */
  private def nodeTrans(innerNode: Graph[Component, LDiEdge]#NodeT):
  Option[(DotGraph, DotNodeStmt)] = {
    val n = innerNode.value.asInstanceOf[Component]

    // The label is something like: {{<in1>in1|<in2>in2}|Cmp[01]|{<out1>out1|<out2>out2}}
    val in = makeLabelList(n.getInputs.getOrElse(Nil))
    val out = makeLabelList(n.getOutputs.getOrElse(Nil))
    val label = s"{{$in}|${nodeName(n)}|{$out}}" // Double '{' are necessary with rankdir=LR !

    // Change the color for unconnected nodes
    val color = if (!n.isConnected) Seq(DotAttr("color", "orange")) else Nil
    Some(root, DotNodeStmt(nodeId(n), Seq(DotAttr("label", label)) ++ color))
  }

  /**
   * Format the name of a Component to display it in a node.
   * @param c Component to display in a node
   * @return the node title value
   */
  private def nodeName(c: Component): String = {
    // Display the component id and description on two lines
    val title = s"Cmp[${c.getId}]"
    val connected = if (c.isConnected) "" else "\\n(NC)"
    s"$title\\n${c.getDescription}$connected"
  }

  /**
   * Return the component ID as String.
   * @param c the Component
   * @return the ID as String
   */
  private def nodeId(c: Component): String = c.getId.toString

  /**
   * Format a list of input or output of a component. Check if it is connected or not and display it.
   * @param l list of input or output of the component
   * @return list formatted for dot record structure
   */
  private def makeLabelList(l: Seq[Port[_]]) = {
    // Return the ID of the port with a label
    l.map(
      x => {
        val id = x.getId
        val nc = if (x.isNotConnected) " (NC)" else ""
        x match {
          case _: InputPort[_] => s"<$id>In[$id]$nc"
          case _: OutputPort[_] => s"<$id>Out[$id]$nc"
        }
      }
    ).mkString("|")
  }

  /**
   * Transform all edges of the graph. Display the wire from an InputPort to an OutputPort of two components.
   * @param innerEdge graph edges
   * @return the same transformation for all edges of the graph
   */
  private def edgeTransformer(innerEdge: Graph[Component, LDiEdge]#EdgeT): Option[(DotGraph, DotEdgeStmt)] = {
    val edge = innerEdge.edge
    val label = edge.label.asInstanceOf[Wire]

    val nodeFrom = edge.from.value.asInstanceOf[Component].getId
    val nodeTo = edge.to.value.asInstanceOf[Component].getId
    val attrs = Seq(DotAttr("label", labelName(label)))
    Some(root, DotEdgeStmt(nodeFrom + ":" + label.from.getId, nodeTo + ":" + label.to.getId, attrs))
  }

  /**
   * Display the type of the connection on thw wire.
   * @param w the wire to display as a edge label
   * @return the type of the connection as a label value
   */
  private def labelName(w: Wire): String = {
    // Something like "hevs.androiduino.dsl.components.fundamentals.uint1"
    val t = w.from.getType

    // Return the child class (ex: uint1) as String
    t.baseClasses.head.asClass.name.toString
  }
}